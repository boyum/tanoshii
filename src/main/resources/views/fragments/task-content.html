<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
  <body>
    <div
      th:fragment="task-content"
      class="task-content"
      th:data-task-index="${taskIndex}"
    >
      <!-- Reading aid toggles -->
      <div class="reading-toggles">
        <button
          type="button"
          class="toggle-btn"
          id="toggle-words"
          onclick="toggleWords(); event.stopPropagation();"
        >
          <span class="toggle-indicator"></span>
          <span class="toggle-label"
            >Show words <kbd class="key-hint">W</kbd></span
          >
        </button>
        <button
          type="button"
          class="toggle-btn"
          id="toggle-autoplay"
          onclick="toggleAutoplay(); event.stopPropagation();"
        >
          <span class="toggle-indicator"></span>
          <span class="toggle-label"
            >Auto-play audio <kbd class="key-hint">A</kbd></span
          >
        </button>
        <button
          type="button"
          class="toggle-btn"
          id="toggle-furigana"
          onclick="toggleFurigana(); event.stopPropagation();"
        >
          <span class="toggle-indicator"></span>
          <span class="toggle-label"
            >Show furigana <kbd class="key-hint">F</kbd></span
          >
        </button>
        <button
          type="button"
          class="toggle-btn"
          id="toggle-romaji"
          onclick="toggleRomaji(); event.stopPropagation();"
        >
          <span class="toggle-indicator"></span>
          <span class="toggle-label"
            >Show romaji <kbd class="key-hint">R</kbd></span
          >
        </button>
        <button
          type="button"
          class="toggle-btn"
          id="toggle-tooltips"
          onclick="toggleTooltips(); event.stopPropagation();"
        >
          <span class="toggle-indicator"></span>
          <span class="toggle-label"
            >Show translations <kbd class="key-hint">T</kbd></span
          >
        </button>
      </div>

      <!-- Audio play/pause button -->
      <div class="audio-control">
        <button
          class="audio-btn"
          id="audio-play-btn"
          th:if="${task.audioHash != null}"
          th:data-audio-hash="${task.audioHash}"
          onclick="toggleAudioPlayback(this);"
        >
          <svg
            class="icon-play"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            width="24"
            height="24"
          >
            <path d="M8 5v14l11-7z" />
          </svg>
          <svg
            class="icon-pause"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            width="24"
            height="24"
            style="display: none"
          >
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
          </svg>
        </button>
        <span class="audio-hint"
          >Press <kbd class="key-hint">Space</kbd> to play</span
        >
      </div>

      <!-- Japanese text with word-by-word romaji -->
      <div class="japanese-container">
        <div class="word-line">
          <th:block th:each="sentence : ${sentencesWithTokens}">
            <span
              th:each="token : ${sentence.tokens}"
              class="word-token"
              th:classappend="${token.meaning != null ? 'has-meaning' : ''}"
            >
              <!-- Furigana version (with ruby tags) -->
              <span
                class="word-surface furigana-version"
                th:utext="${token.furiganaHtml}"
                >私</span
              >
              <!-- Plain version (no furigana) -->
              <span
                class="word-surface plain-version"
                th:text="${token.surface}"
                >私</span
              >
              <!-- Romaji below -->
              <span class="word-romaji" th:text="${token.romaji}">watashi</span>
              <!-- Tooltip -->
              <span
                th:if="${token.meaning != null}"
                class="word-tooltip"
                th:text="${token.meaning}"
                >meaning</span
              >
            </span>
          </th:block>
        </div>
      </div>

      <!-- Answer input -->
      <div class="answer-section">
        <label for="user-answer" class="answer-label">Your translation:</label>
        <textarea
          id="user-answer"
          class="answer-input"
          placeholder="Type your English translation here... (Enter to submit, Shift+Enter for new line)"
          rows="3"
          onkeydown="handleAnswerKeydown(event)"
        ></textarea>
        <button
          class="btn btn-secondary check-answer-btn"
          onclick="checkAnswer(); event.stopPropagation();"
        >
          Check Answer <kbd class="key-hint-btn">Enter</kbd>
        </button>
      </div>

      <!-- Feedback area -->
      <div id="feedback-area" class="feedback-area" style="display: none">
        <!-- Will be filled by check answer action -->
      </div>

      <!-- Translation area (initially hidden) -->
      <div id="translation-area" class="translation-area">
        <!-- Will be filled by reveal action -->
      </div>

      <!-- Vocabulary hints -->
      <div class="vocabulary-hints" th:if="${not #lists.isEmpty(words)}">
        <span class="hint-label">Vocabulary hints:</span>
        <div class="word-chips">
          <span class="word-chip" th:each="word : ${words}">
            <span class="word-jp" th:text="${word.japanese}">Japanese</span>
            <span class="word-en" th:text="${word.english}">English</span>
          </span>
        </div>
      </div>
    </div>

    <script>
      // Global audio instance for play/pause control (avoid redeclaration on HTMX swap)
      if (typeof currentAudio === "undefined") {
        var currentAudio = null;
        var isPlaying = false;
      }

      function toggleAudioPlayback(button) {
        const hash = button.dataset.audioHash;
        if (!hash) return;

        if (isPlaying && currentAudio) {
          // Pause
          currentAudio.pause();
          setPlayingState(false);
        } else {
          // Play (or resume)
          if (currentAudio && currentAudio.src.includes(hash)) {
            // Resume existing audio
            currentAudio
              .play()
              .catch((e) => console.error("Audio playback failed:", e));
          } else {
            // Create new audio
            playAudioByHash(hash);
          }
        }
      }

      function playAudioByHash(hash) {
        // Stop any existing audio
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        currentAudio = new Audio(`/audio/${hash}.mp3`);
        currentAudio.addEventListener("ended", () => setPlayingState(false));
        currentAudio.addEventListener("pause", () => setPlayingState(false));
        currentAudio.addEventListener("play", () => setPlayingState(true));
        currentAudio.play().catch((e) => {
          console.error("Audio playback failed:", e);
          setPlayingState(false);
        });
      }

      function setPlayingState(playing) {
        isPlaying = playing;
        const btn = document.getElementById("audio-play-btn");
        if (btn) {
          const playIcon = btn.querySelector(".icon-play");
          const pauseIcon = btn.querySelector(".icon-pause");
          if (playIcon) playIcon.style.display = playing ? "none" : "block";
          if (pauseIcon) pauseIcon.style.display = playing ? "block" : "none";
        }
      }

      function toggleWords() {
        const enabled = localStorage.getItem("wordsEnabled") !== "false";
        localStorage.setItem("wordsEnabled", !enabled);
        applyReadingAidSettings();
      }

      function toggleAutoplay() {
        const enabled = localStorage.getItem("autoplayEnabled") !== "false";
        localStorage.setItem("autoplayEnabled", !enabled);
        applyReadingAidSettings();
      }

      function toggleFurigana() {
        const enabled = localStorage.getItem("furiganaEnabled") !== "false";
        localStorage.setItem("furiganaEnabled", !enabled);
        applyReadingAidSettings();
      }

      function toggleRomaji() {
        const enabled = localStorage.getItem("romajiEnabled") !== "false";
        localStorage.setItem("romajiEnabled", !enabled);
        applyReadingAidSettings();
      }

      function toggleTooltips() {
        const enabled = localStorage.getItem("tooltipsEnabled") !== "false";
        localStorage.setItem("tooltipsEnabled", !enabled);
        applyReadingAidSettings();
      }

      function applyReadingAidSettings() {
        const wordsEnabled = localStorage.getItem("wordsEnabled") !== "false";
        const autoplayEnabled =
          localStorage.getItem("autoplayEnabled") !== "false";
        const furiganaEnabled =
          localStorage.getItem("furiganaEnabled") !== "false";
        const romajiEnabled = localStorage.getItem("romajiEnabled") !== "false";
        const tooltipsEnabled =
          localStorage.getItem("tooltipsEnabled") !== "false";

        // Update toggle buttons
        const wordsBtn = document.getElementById("toggle-words");
        const autoplayBtn = document.getElementById("toggle-autoplay");
        const furiganaBtn = document.getElementById("toggle-furigana");
        const romajiBtn = document.getElementById("toggle-romaji");
        const tooltipsBtn = document.getElementById("toggle-tooltips");

        if (wordsBtn) {
          wordsBtn.classList.toggle("enabled", wordsEnabled);
        }
        if (autoplayBtn) {
          autoplayBtn.classList.toggle("enabled", autoplayEnabled);
        }
        if (furiganaBtn) {
          furiganaBtn.classList.toggle("enabled", furiganaEnabled);
        }
        if (romajiBtn) {
          romajiBtn.classList.toggle("enabled", romajiEnabled);
        }
        if (tooltipsBtn) {
          tooltipsBtn.classList.toggle("enabled", tooltipsEnabled);
        }

        // Update words visibility
        const japaneseContainer = document.querySelector(".japanese-container");
        if (japaneseContainer) {
          japaneseContainer.style.display = wordsEnabled ? "block" : "none";
        }

        // Toggle furigana vs plain text
        document.querySelectorAll(".furigana-version").forEach((el) => {
          el.style.display = furiganaEnabled ? "inline" : "none";
        });

        document.querySelectorAll(".plain-version").forEach((el) => {
          el.style.display = furiganaEnabled ? "none" : "inline";
        });

        // Update romaji visibility (word-by-word)
        document.querySelectorAll(".word-romaji").forEach((el) => {
          el.style.display = romajiEnabled ? "inline" : "none";
        });

        // Update tooltips visibility
        if (japaneseContainer) {
          if (tooltipsEnabled) {
            japaneseContainer.classList.remove("tooltips-disabled");
          } else {
            japaneseContainer.classList.add("tooltips-disabled");
          }
        }
      }

      function autoPlayIfEnabled() {
        const autoplayEnabled =
          localStorage.getItem("autoplayEnabled") !== "false";
        if (autoplayEnabled) {
          const audioBtn = document.querySelector(
            ".audio-btn[data-audio-hash]",
          );
          if (audioBtn) {
            const hash = audioBtn.dataset.audioHash;
            // Small delay to ensure the UI has rendered
            setTimeout(() => playAudioByHash(hash), 100);
          }
        }
      }

      // Apply settings on load
      applyReadingAidSettings();
      // Auto-play audio if enabled
      autoPlayIfEnabled();

      function handleAnswerKeydown(event) {
        // Submit on Enter, new line on Shift+Enter
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          checkAnswer();
        }
      }

      async function checkAnswer() {
        const textarea = document.getElementById("user-answer");
        const feedbackArea = document.getElementById("feedback-area");
        const checkBtn = document.querySelector(".check-answer-btn");

        const userAnswer = textarea.value.trim();
        if (!userAnswer) {
          alert("Please enter your translation first");
          return;
        }

        // Get session and task info from page
        const taskContainer = document.querySelector("[data-task-index]");
        if (!taskContainer) return;

        const taskIndex = taskContainer.dataset.taskIndex;
        const pathParts = window.location.pathname.split("/");
        const sessionId = pathParts[pathParts.indexOf("session") + 1];

        // Disable button while checking
        checkBtn.disabled = true;
        checkBtn.textContent = "Checking...";

        try {
          const formData = new FormData();
          formData.append("userAnswer", userAnswer);

          const response = await fetch(
            `/api/session/${sessionId}/task/${taskIndex}/check`,
            {
              method: "POST",
              body: formData,
            },
          );

          const feedback = await response.text();
          feedbackArea.innerHTML = feedback;
          feedbackArea.style.display = "block";
        } catch (e) {
          console.error("Failed to check answer:", e);
          feedbackArea.innerHTML =
            '<div class="feedback-error">Failed to check answer. Please try again.</div>';
          feedbackArea.style.display = "block";
        } finally {
          checkBtn.disabled = false;
          checkBtn.textContent = "Check Answer";
        }
      }

      // Handle copy event to ensure clean text copying (no line breaks between words)
      document.addEventListener("copy", (event) => {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        // Check if selection is within japanese-container
        const container = document.querySelector(".japanese-container");
        if (!container || !container.contains(selection.anchorNode)) return;

        // Get all word-surface elements in the selection
        const range = selection.getRangeAt(0);
        const selectedContainer = range.cloneContents();
        const wordSurfaces =
          selectedContainer.querySelectorAll(".word-surface");

        if (wordSurfaces.length > 0) {
          // Extract just the text from word-surface elements
          let cleanText = "";
          wordSurfaces.forEach((surface) => {
            cleanText += surface.textContent;
          });

          if (cleanText) {
            // Override clipboard with clean text
            event.preventDefault();
            event.clipboardData.setData("text/plain", cleanText);
          }
        }
      });

      // Clear answer and feedback when navigating
      document.body.addEventListener("htmx:beforeRequest", function (event) {
        if (event.detail.target.id === "task-container") {
          const textarea = document.getElementById("user-answer");
          const feedbackArea = document.getElementById("feedback-area");
          if (textarea) textarea.value = "";
          if (feedbackArea) {
            feedbackArea.innerHTML = "";
            feedbackArea.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
